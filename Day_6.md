# Day 6 문제 상세 해설

## 1. Binary Search

### 문제 설명
오름차순으로 정렬된 정수 배열 `nums`와 찾고자 하는 숫자 `target`이 주어집니다. 이때, `target`이 `nums` 배열 안에 존재하면 그 인덱스를 반환하고, 존재하지 않으면 -1을 반환해야 합니다.

### 입력 예시
- `nums = [-1,0,3,5,9,12], target = 9`
- `nums = [-1,0,3,5,9,12], target = 2`

### 출력 예시
- `nums = [-1,0,3,5,9,12], target = 9` → `4` (9는 인덱스 4에 있음)
- `nums = [-1,0,3,5,9,12], target = 2` → `-1` (2는 배열에 없음)

### 접근 방법 상세 설명
이 문제는 **이진 탐색(Binary Search)** 알고리즘을 사용하여 효율적으로 해결할 수 있습니다. 이진 탐색은 정렬된 배열에서 특정 값을 찾는 알고리즘으로, 각 단계에서 검색 범위를 절반으로 줄여나가는 방식입니다.

#### 알고리즘 단계별 설명
1. 왼쪽(left)과 오른쪽(right) 포인터를 배열의 시작(0)과 끝(length-1)으로 초기화합니다.
2. left가 right보다 작거나 같은 동안 다음을 반복합니다:
   - 중간점(mid)을 계산합니다: `mid = (left + right) / 2` (정수 나눗셈)
   - 만약 `nums[mid] == target`이면, mid를 반환합니다.
   - 만약 `nums[mid] < target`이면, 왼쪽 포인터를 `mid + 1`로 이동합니다.
   - 만약 `nums[mid] > target`이면, 오른쪽 포인터를 `mid - 1`로 이동합니다.
3. 만약 반복문이 종료되면(즉, `left > right`), target은 배열에 없으므로 -1을 반환합니다.

#### 코드 구현
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

#### 단계별 예시
입력: `nums = [-1,0,3,5,9,12], target = 9`

1. 초기 상태: `left = 0, right = 5`
2. `mid = (0 + 5) // 2 = 2`, `nums[mid] = 3`
3. 3 < 9 이므로 `left = mid + 1 = 3`
4. `mid = (3 + 5) // 2 = 4`, `nums[mid] = 9`
5. 9 == 9 이므로 `4`를 반환

입력: `nums = [-1,0,3,5,9,12], target = 2`

1. 초기 상태: `left = 0, right = 5`
2. `mid = (0 + 5) // 2 = 2`, `nums[mid] = 3`
3. 3 > 2 이므로 `right = mid - 1 = 1`
4. `mid = (0 + 1) // 2 = 0`, `nums[mid] = -1`
5. -1 < 2 이므로 `left = mid + 1 = 1`
6. `mid = (1 + 1) // 2 = 1`, `nums[mid] = 0`
7. 0 < 2 이므로 `left = mid + 1 = 2`
8. `left = 2, right = 1`, `left > right`이므로 반복문 종료
9. `-1`을 반환

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(log n) - 각 단계에서 검색 범위가 절반으로 줄어듭니다.
- **공간 복잡도**: O(1) - 추가 공간을 사용하지 않습니다.

#### 이진 탐색의 핵심 포인트
이진 탐색은 정렬된 배열에서 특정 값을 찾는 가장 효율적인 방법 중 하나입니다. 선형 탐색(Linear Search)은 배열의 모든 요소를 확인해야 하므로 O(n) 시간이 걸리지만, 이진 탐색은 O(log n) 시간으로 훨씬 빠릅니다.

## 2. Search a 2D Matrix

### 문제 설명
각 행이 오름차순으로 정렬되어 있고, 각 행의 첫 번째 요소가 이전 행의 마지막 요소보다 큰 m x n 행렬 `matrix`가
주어집니다. 이때, `target` 값이 `matrix` 내에 존재하는지 여부를 확인해야 합니다.

### 입력 예시
- `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3`
- `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13`

### 출력 예시
- `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3` → `true`
- `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13` → `false`

### 접근 방법 상세 설명
이 문제는 **2차원 배열에서의 이진 탐색**을 활용하여 해결할 수 있습니다. 특히, 행렬의 특성(각 행이 정렬되어 있고, 다음 행의 첫 요소가 이전 행의 마지막 요소보다 큼)을 이용하면 2D 행렬을 1D 정렬 배열처럼 생각할 수 있습니다.

#### 알고리즘 단계별 설명
1. m x n 행렬을 가상의 1D 배열로 변환하여 생각합니다. 인덱스는 0부터 m*n-1까지입니다.
2. 일반적인 이진 탐색 알고리즘을 적용합니다.
3. 중간점 계산 후, 해당 인덱스를 2D 행렬의 좌표(row, col)로 변환합니다:
   - `row = mid / n`
   - `col = mid % n`
4. 변환된 좌표의 값과 target을 비교하여 이진 탐색을 계속합니다.

#### 코드 구현
```python
def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False
```

#### 단계별 예시
입력: `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3`

1. 초기 상태: `left = 0, right = 11` (총 12개 요소)
2. `mid = (0 + 11) // 2 = 5`, `row = 5 // 4 = 1, col = 5 % 4 = 1`, `matrix[1][1] = 11`
3. 11 > 3 이므로 `right = mid - 1 = 4`
4. `mid = (0 + 4) // 2 = 2`, `row = 2 // 4 = 0, col = 2 % 4 = 2`, `matrix[0][2] = 5`
5. 5 > 3 이므로 `right = mid - 1 = 1`
6. `mid = (0 + 1) // 2 = 0`, `row = 0 // 4 = 0, col = 0 % 4 = 0`, `matrix[0][0] = 1`
7. 1 < 3 이므로 `left = mid + 1 = 1`
8. `mid = (1 + 1) // 2 = 1`, `row = 1 // 4 = 0, col = 1 % 4 = 1`, `matrix[0][1] = 3`
9. 3 == 3 이므로 `True`를 반환

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(log(m*n)) - 여기서 m은 행의 수, n은 열의 수입니다.
- **공간 복잡도**: O(1) - 추가 공간을 사용하지 않습니다.

#### 2D 행렬에서의 이진 탐색의 핵심 포인트
이 문제의 핵심은 2D 행렬을 1D 배열로 변환하는 방법과, 1D 인덱스를 다시 2D 좌표로 변환하는 방법을 이해하는 것입니다. 이 변환 공식을 사용하면 복잡한 2D 탐색 문제를 단순한 1D 이진 탐색으로 효율적으로 해결할 수 있습니다.

## 3. Koko Eating Bananas

### 문제 설명
코코라는 원숭이가 바나나 더미를 먹으려 합니다. 배열 `piles[i]`는 i번째 더미에 있는 바나나의 수를 나타냅니다.
경비원은 h시간 후에 돌아올 예정입니다. 코코는 k개의 바나나를 한 시간에 먹을 수 있는데, 만약 더미에 k개보다 적은 바나나가 있다면 해당 시간 내에 모두 먹습니다. 코코가 h시간 내에 모든 바나나를 먹을 수 있는 최소 k값을 구해야 합니다.

### 입력 예시
- `piles = [3,6,7,11], h = 8`
- `piles = [30,11,23,4,20], h = 5`

### 출력 예시
- `piles = [3,6,7,11], h = 8` → `4`
- `piles = [30,11,23,4,20], h = 5` → `30`

### 접근 방법 상세 설명
이 문제는 **이진 탐색**을 사용하여 최적의 k 값을 찾는 문제입니다. k의 범위는 1부터 바나나 더미 중 최대값까지입니다(최악의 경우). 이 범위 내에서 이진 탐색을 통해 조건을 만족하는 최소 k를 찾아야 합니다.

#### 알고리즘 단계별 설명
1. k의 최소값은 1, 최대값은 `max(piles)`로 설정합니다.
2. 이진 탐색을 사용하여 가능한 k 값을 찾습니다:
   - 중간값 k를 선택합니다.
   - 코코가 해당 k로 모든 바나나를 h시간 내에 먹을 수 있는지 확인합니다.
   - 가능하다면, 더 작은 k를 찾기 위해 오른쪽 범위를 줄입니다.
   - 불가능하다면, 더 큰 k가 필요하므로 왼쪽 범위를 늘립니다.
3. 위 과정을 반복하여 조건을 만족하는 최소 k 값을 찾습니다.

#### 코드 구현
```python
import math

def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    
    while left < right:
        mid = (left + right) // 2
        hours_needed = sum(math.ceil(pile / mid) for pile in piles)
        
        if hours_needed <= h:
            right = mid
        else:
            left = mid + 1
    
    return left
```

#### 단계별 예시
입력: `piles = [3,6,7,11], h = 8`

1. 초기 상태: `left = 1, right = 11`
2. `mid = (1 + 11) // 2 = 6`
3. 속도 6으로 먹는 경우:
   - 3을 먹는데 필요한 시간: `math.ceil(3/6) = 1` 시간
   - 6을 먹는데 필요한 시간: `math.ceil(6/6) = 1` 시간
   - 7을 먹는데 필요한 시간: `math.ceil(7/6) = 2` 시간
   - 11을 먹는데 필요한 시간: `math.ceil(11/6) = 2` 시간
   - 총 필요 시간: 1 + 1 + 2 + 2 = 6 시간 (h=8보다 작음)
4. 조건을 만족하므로 `right = mid = 6`
5. `mid = (1 + 6) // 2 = 3`
6. 속도 3으로 먹는 경우:
   - 총 필요 시간: `math.ceil(3/3) + math.ceil(6/3) + math.ceil(7/3) + math.ceil(11/3) = 1 + 2 + 3 + 4 = 10` 시간 (h=8보다 큼)
7. 조건을 만족하지 않으므로 `left = mid + 1 = 4`
8. `mid = (4 + 6) // 2 = 5`
9. 속도 5로 먹는 경우:
   - 총 필요 시간: `math.ceil(3/5) + math.ceil(6/5) + math.ceil(7/5) + math.ceil(11/5) = 1 + 2 + 2 + 3 = 8` 시간 (h=8과 같음)
10. 조건을 만족하므로 `right = mid = 5`
11. `mid = (4 + 5) // 2 = 4`
12. 속도 4로 먹는 경우:
    - 총 필요 시간: `math.ceil(3/4) + math.ceil(6/4) + math.ceil(7/4) + math.ceil(11/4) = 1 + 2 + 2 + 3 = 8` 시간 (h=8과 같음)
13. 조건을 만족하므로 `right = mid = 4`
14. `left = 4, right = 4`이므로 반복문 종료
15. `4`를 반환

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(N log M) - 여기서 N은 바나나 더미의 수, M은 최대 바나나 수입니다.
- **공간 복잡도**: O(1) - 추가 공간을 사용하지 않습니다.

#### 이진 탐색을 사용한 최적화 문제의 핵심 포인트
이 문제는 '결정 문제'의 일종으로, 특정 k 값이 조건을 만족하는지 여부를 확인하고, 이를 통해 최적의 k를 찾는 방법을 보여줍니다. 이진 탐색은 이런 유형의 최적화 문제에 매우 효과적인 접근 방법입니다.

문제의 핵심은 다음과 같습니다:
1. k 값의 범위 설정 (최소값과 최대값 결정)
2. 중간값 k를 선택하여 조건 만족 여부 확인
3. 조건에 따라 검색 범위 좁히기
4. 최종적으로 조건을 만족하는 최소 k 값 찾기

이진 탐색을 이용한 최적화 문제는 알고리즘 인터뷰에서 자주 출제되는 유형이므로, 이 패턴을 잘 이해하고 적용하는 것이 중요합니다.
