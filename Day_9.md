# Day 9 문제 상세 해설

## 1. Number of Islands

### 문제 설명
`m × n` 크기의 2D 격자 맵이 주어집니다. 이 맵은 '1'(육지)과 '0'(물)로 이루어져 있습니다. 섬은 수평 또는 수직으로 연결된 육지들의 집합으로 정의되며, 맵 밖으로 나가는 것은 물로 간주합니다. 주어진 맵에서 섬의 수를 구해야 합니다.

### 입력 예시
- 예시 1:
  ```
  grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  ```
- 예시 2:
  ```
  grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  ```

### 출력 예시
- 예시 1: `1` (하나의 섬이 있음)
- 예시 2: `3` (세 개의 섬이 있음)

### 접근 방법 상세 설명
이 문제는 **연결 요소(Connected Component)** 찾기 문제로, 그래프 탐색 알고리즘(DFS 또는 BFS)을 사용하여 해결할 수 있습니다. 기본적인 아이디어는 다음과 같습니다:

1. 격자를 순회하면서 육지('1')를 발견하면, 해당 육지에서 시작하여 연결된 모든 육지를 탐색합니다.
2. 탐색한 육지는 방문했다는 표시로 다른 값(예: '0' 또는 '2')으로 변경하여 중복 방문을 방지합니다.
3. 각 새로운 육지 발견 시 섬의 수를 증가시킵니다.

이 문제는 DFS나 BFS 모두 사용할 수 있으며, 여기서는 두 접근법을 모두 보여드리겠습니다.

#### 방법 1: 깊이 우선 탐색(DFS)
DFS는 한 방향으로 최대한 깊이 탐색한 후 더 이상 갈 수 없을 때 다른 방향을 탐색하는 방법입니다.

#### 알고리즘 단계별 설명 (DFS)
1. 섬의 수를 저장할 변수 `count`를 0으로 초기화합니다.
2. 격자를 순회합니다:
   - 만약 현재 셀이 육지('1')라면:
     - `count`를 1 증가시킵니다.
     - 현재 육지에서 DFS를 시작하여 연결된 모든 육지를 방문 표시합니다.
3. DFS 함수에서는:
   - 현재 위치가 격자 범위를 벗어나거나 물('0')이면 탐색을 중단합니다.
   - 현재 위치를 방문 표시(물로 변경)합니다.
   - 현재 위치의 상하좌우 네 방향에 대해 재귀적으로 DFS를 호출합니다.
4. 격자 순회를 완료한 후 `count`를 반환합니다.

#### 코드 구현 (DFS)
```python
def numIslands(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    def dfs(row, col):
        # 격자 범위를 벗어나거나 물('0')인 경우 종료
        if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] == '0':
            return
        
        # 현재 위치를 방문 표시 (물로 변경)
        grid[row][col] = '0'
        
        # 상하좌우 네 방향에 대해 DFS 호출
        dfs(row+1, col)
        dfs(row-1, col)
        dfs(row, col+1)
        dfs(row, col-1)
    
    # 격자 순회
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    
    return count
```

#### 방법 2: 너비 우선 탐색(BFS)
BFS는 시작점에서 가까운 노드부터 차례대로 탐색하는 방법으로, 큐를 사용하여 구현합니다.

#### 알고리즘 단계별 설명 (BFS)
1. 섬의 수를 저장할 변수 `count`를 0으로 초기화합니다.
2. 격자를 순회합니다:
   - 만약 현재 셀이 육지('1')라면:
     - `count`를 1 증가시킵니다.
     - 현재 육지에서 BFS를 시작하여 연결된 모든 육지를 방문 표시합니다.
3. BFS 함수에서는:
   - 시작 위치를 큐에 넣고 방문 표시합니다.
   - 큐가 빌 때까지 반복:
     - 큐에서 위치를 하나 꺼냅니다.
     - 해당 위치의 상하좌우 네 방향에 대해:
       - 만약 격자 범위 내이고 육지('1')라면 큐에 넣고 방문 표시합니다.
4. 격자 순회를 완료한 후 `count`를 반환합니다.

#### 코드 구현 (BFS)
```python
from collections import deque

def numIslands(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    def bfs(row, col):
        queue = deque([(row, col)])
        grid[row][col] = '0'  # 시작 위치 방문 표시
        
        while queue:
            r, c = queue.popleft()
            
            # 상하좌우 네 방향 확인
            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                
                # 격자 범위 내이고 육지('1')인 경우
                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == '1':
                    queue.append((nr, nc))
                    grid[nr][nc] = '0'  # 방문 표시
    
    # 격자 순회
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                bfs(i, j)
    
    return count
```

#### 단계별 예시 (DFS)
입력: 
```
grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
```

1. (0,0)에서 시작, grid[0][0] = '1'이므로:
   - count = 1 증가
   - DFS(0, 0) 호출:
     - grid[0][0] = '0'으로 변경 (방문 표시)
     - 상하좌우 탐색:
       - DFS(1, 0): grid[1][0] = '1'이므로 방문 표시하고 재귀 호출
       - DFS(0, 1): grid[0][1] = '1'이므로 방문 표시하고 재귀 호출
       - ... 연결된 모든 육지 방문 표시
   - 첫 번째 섬 탐색 완료 (2x2 크기의 섬)

2. 계속 격자 순회, (2,2)에서 grid[2][2] = '1'이므로:
   - count = 2 증가
   - DFS(2, 2) 호출:
     - grid[2][2] = '0'으로 변경 (방문 표시)
     - 상하좌우 탐색 (연결된 육지 없음)
   - 두 번째 섬 탐색 완료 (1x1 크기의 섬)

3. 계속 격자 순회, (3,3)에서 grid[3][3] = '1'이므로:
   - count = 3 증가
   - DFS(3, 3) 호출:
     - grid[3][3] = '0'으로 변경 (방문 표시)
     - 상하좌우 탐색:
       - DFS(3, 4): grid[3][4] = '1'이므로 방문 표시하고 재귀 호출
   - 세 번째 섬 탐색 완료 (1x2 크기의 섬)

4. 격자 순회 완료, 최종 결과: count = 3

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(M×N) - 각 셀을 한 번씩 방문합니다.
- **공간 복잡도**: 
  - DFS: O(M×N) - 최악의 경우 재귀 호출 스택의 깊이가 M×N이 될 수 있습니다.
  - BFS: O(min(M,N)) - 최악의 경우 큐의 크기는 격자의 한 행 또는 열의 크기와 같을 수 있습니다.

#### 섬의 수 계산의 핵심 포인트
1. **연결 요소 찾기**: 그래프 이론에서 연결 요소(Connected Component)를 찾는 문제와 동일합니다.
2. **방문 표시**: 이미 방문한 노드를 표시하여 중복 방문을 방지합니다.
3. **DFS vs BFS**: 두 방법 모두 사용 가능하며, 문제 특성에 따라 선택할 수 있습니다.

이 문제는 그래프 탐색 알고리즘의 기본적인 응용으로, 실제 세계의 많은 문제(예: 네트워크 연결성, 이미지 세그멘테이션 등)에 적용할 수 있는 패턴입니다.

## 2. 01 Matrix

### 문제 설명
`m × n` 크기의 행렬이 주어지며, 이 행렬은 0과 1로만 구성되어 있습니다. 각 셀에 대해, 가장 가까운 0까지의 거리를 계산해야 합니다. 거리는 맨해튼 거리로 계산하며, 이는 두 셀 사이의 수직 및 수평 거리의 합입니다.

### 입력 예시
- 예시 1: `mat = [[0,0,0],[0,1,0],[0,0,0]]`
- 예시 2: `mat = [[0,0,0],[0,1,0],[1,1,1]]`

### 출력 예시
- 예시 1: `[[0,0,0],[0,1,0],[0,0,0]]` (모든 0은 자신까지의 거리가 0이고, 중앙의 1은 상하좌우 모두 0이므로 거리가 1)
- 예시 2: `[[0,0,0],[0,1,0],[1,2,1]]` (마지막 행의 1들 중, 왼쪽과 오른쪽 1은 가장 가까운 0까지 거리가 1, 중앙의 1은 거리가 2)

### 접근 방법 상세 설명
이 문제는 **다중 시작점 BFS**를 사용하여 효율적으로 해결할 수 있습니다. 기본 아이디어는 다음과 같습니다:

1. 모든 0을 시작점으로 하는 BFS를 수행합니다.
2. BFS를 통해 각 셀에서 가장 가까운 0까지의 거리를 계산합니다.

#### 알고리즘 단계별 설명
1. 결과 행렬을 초기화합니다:
   - 0인 셀은 거리 0으로 설정합니다.
   - 1인 셀은 무한대(또는 매우 큰 값)로 설정합니다.
2. 큐를 초기화하고 모든 0인 셀의 좌표를 큐에 넣습니다.
3. BFS를 수행합니다:
   - 큐에서 셀을 꺼냅니다.
   - 해당 셀의 상하좌우 네 방향을 확인합니다.
   - 만약 인접 셀의 현재 거리가 현재 셀의 거리 + 1보다 크면, 인접 셀의 거리를 업데이트하고 큐에 추가합니다.
4. BFS가 완료되면 결과 행렬을 반환합니다.

#### 코드 구현
```python
from collections import deque

def updateMatrix(mat):
    if not mat or not mat[0]:
        return []
    
    m, n = len(mat), len(mat[0])
    dist = [[float('inf')] * n for _ in range(m)]
    queue = deque()
    
    # 모든 0인 셀을 시작점으로 큐에 추가
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 0:
                dist[i][j] = 0
                queue.append((i, j))
    
    # BFS
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while queue:
        row, col = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            
            # 격자 범위 내이고, 거리 업데이트가 필요한 경우
            if 0 <= nr < m and 0 <= nc < n and dist[nr][nc] > dist[row][col] + 1:
                dist[nr][nc] = dist[row][col] + 1
                queue.append((nr, nc))
    
    return dist
```

#### 단계별 예시
입력: `mat = [[0,0,0],[0,1,0],[1,1,1]]`

1. 초기화:
   - dist = [
       [0, 0, 0],
       [0, inf, 0],
       [inf, inf, inf]
     ]
   - queue = [(0,0), (0,1), (0,2), (1,0), (1,2)]

2. BFS 수행:
   - (0,0) 처리:
     - 인접 셀 (1,0): 이미 거리가 0이므로 변경 없음
     - 인접 셀 (0,1): 이미 거리가 0이므로 변경 없음
   - (0,1) 처리:
     - 인접 셀 (0,0), (0,2), (1,1): 첫 두 개는 이미 거리가 0, (1,1)은 dist[1][1] = 1로 업데이트하고 큐에 추가
   - ... (BFS 계속 진행)

3. 최종 결과:
   - dist = [
       [0, 0, 0],
       [0, 1, 0],
       [1, 2, 1]
     ]

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(m×n) - 각 셀을 한 번씩 방문합니다.
- **공간 복잡도**: O(m×n) - 결과 행렬과 큐에 각각 최대 m×n 개의 요소가 저장될 수 있습니다.

#### 01 행렬 거리 계산의 핵심 포인트
1. **다중 시작점 BFS**: 모든 0인 셀에서 동시에 BFS를 시작하는 것이 핵심입니다.
2. **거리 최소화**: BFS의 성질에 따라 가장 먼저 방문하는 경로가 가장 짧은 경로입니다.
3. **효율성**: 각 셀을 한 번만 방문하므로 효율적입니다.

#### 대체 접근법: DP(동적 계획법)
다른 접근법으로는 DP를 사용할 수도 있습니다. 각 셀에 대해 네 방향에서 오는 거리를 고려하여 최소 거리를 계산합니다. 이 방법은 두 번의 패스로 구현됩니다:
1. 좌상에서 우하로 패스: 왼쪽과 위쪽에서 오는 거리만 고려
2. 우하에서 좌상으로 패스: 오른쪽과 아래쪽에서 오는 거리도 고려

이 문제는 그래프 탐색과 동적 계획법 모두 적용할 수 있는 좋은 예입니다.

## 3. Rotting Oranges

### 문제 설명
`m × n` 크기의 격자가 주어지며, 각 셀은 다음 세 값 중 하나를 가질 수 있습니다:
- 0: 빈 셀
- 1: 신선한 오렌지
- 2: 썩은 오렌지

매 분마다, 썩은 오렌지는 상하좌우로 인접한 신선한 오렌지를 썩게 만듭니다. 모든 신선한 오렌지가 썩게 되는 최소 시간(분)을 반환해야 합니다. 만약 불가능하다면 -1을 반환합니다.

### 입력 예시
- 예시 1: `grid = [[2,1,1],[1,1,0],[0,1,1]]`
- 예시 2: `grid = [[2,1,1],[0,1,1],[1,0,1]]`
- 예시 3: `grid = [[0,2]]`

### 출력 예시
- 예시 1: `4` (4분 후에 모든 오렌지가 썩음)
- 예시 2: `-1` (맨 왼쪽 아래 오렌지는 절대 썩지 않음)
- 예시 3: `0` (이미 모든 오렌지가 썩었거나 없음)

### 접근 방법 상세 설명
이 문제는 **다중 시작점 BFS**를 사용하여 해결할 수 있습니다. 썩은 오렌지에서 시작하여 신선한 오렌지로 퍼져나가는 과정을 시뮬레이션합니다.

#### 알고리즘 단계별 설명
1. 격자를 순회하며 다음 정보를 수집합니다:
   - 모든 썩은 오렌지의 위치를 큐에 추가
   - 신선한 오렌지의 총 개수를 계산
2. 만약 신선한 오렌지가 없다면, 0을 반환합니다.
3. BFS를 수행합니다:
   - 현재 레벨의 모든 썩은 오렌지를 처리하고 시간을 1 증가시킵니다.
   - 각 썩은 오렌지의 상하좌우 네 방향을 확인하여 신선한 오렌지를 썩게 만듭니다.
   - 오렌지가 썩을 때마다 신선한 오렌지 카운터를 감소시킵니다.
4. BFS가 완료된 후, 만약 신선한 오렌지가 여전히 남아있다면 모든 오렌지를 썩게 만들 수 없다는 의미이므로 -1을 반환합니다.
5. 그렇지 않으면, 경과된 시간을 반환합니다.

#### 코드 구현
```python
from collections import deque

def orangesRotting(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # 모든 썩은 오렌지의 위치를 큐에 추가하고 신선한 오렌지 수 계산
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 2:
                queue.append((i, j))
            elif grid[i][j] == 1:
                fresh_count += 1
    
    # 신선한 오렌지가 없는 경우
    if fresh_count == 0:
        return 0
    
    # BFS
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    time = 0
    
    while queue and fresh_count > 0:
        size = len(queue)
        
        # 현재 레벨의 모든 썩은 오렌지 처리
        for _ in range(size):
            row, col = queue.popleft()
            
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                
                # 격자 범위 내이고 신선한 오렌지인 경우
                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                    grid[nr][nc] = 2  # 오렌지 썩게 만들기
                    fresh_count -= 1
                    queue.append((nr, nc))
        
        time += 1
    
    # 신선한 오렌지가 남아있는 경우
    if fresh_count > 0:
        return -1
    
    return time
```

#### 단계별 예시
입력: `grid = [[2,1,1],[1,1,0],[0,1,1]]`

1. 초기화:
   - queue = [(0,0)] (첫 번째 썩은 오렌지의 위치)
   - fresh_count = 6 (신선한 오렌지 6개)

2. BFS 수행:
   - 시간 0, 큐 크기 1:
     - (0,0) 처리: 인접한 (1,0)과 (0,1)이 신선한 오렌지이므로 썩게 만들고 큐에 추가
     - fresh_count = 4, queue = [(1,0), (0,1)]
   
   - 시간 1, 큐 크기 2:
     - (1,0) 처리: 인접한 (1,1)이 신선한 오렌지이므로 썩게 만들고 큐에 추가
     - (0,1) 처리: 인접한 (0,2)가 신선한 오렌지이므로 썩게 만들고 큐에 추가
     - fresh_count = 2, queue = [(1,1), (0,2)]
   
   - 시간 2, 큐 크기 2:
     - (1,1) 처리: 인접한 셀 중 신선한 오렌지 없음
     - (0,2) 처리: 인접한 셀 중 신선한 오렌지 없음
     - fresh_count = 2, queue = []
   
   - 큐가 비었으나 여전히 신선한 오렌지가 2개 남아있음
   
3. 격자 상태:
   ```
   [2,2,2]
   [2,2,0]
   [0,1,1]
   ```
   
4. BFS를 계속할 수 없으므로 -1 반환하는 것 같으나, 이 예시는 모든 오렌지가 썩을 수 있습니다. 큐가 비어있는 것으로 나왔으나, 실제로는 코드 구현에 문제가 있거나 예시 설명에 오류가 있을 수 있습니다.

정정된 입력: `grid = [[2,1,1],[1,1,0],[0,1,1]]`

실제 BFS 수행 시:
- 0분: 초기 상태
- 1분: (0,0)의 썩은 오렌지가 (0,1)과 (1,0)을 썩게 만듭니다.
- 2분: (0,1)이 (0,2)를, (1,0)이 (1,1)을 썩게 만듭니다.
- 3분: (1,1)이 (2,1)을 썩게 만듭니다.
- 4분: (2,1)이 (2,2)를 썩게 만듭니다.

4분 후에 모든 오렌지가 썩게 되므로 결과는 4입니다.

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(m×n) - 각 셀을 최대 한 번씩 방문합니다.
- **공간 복잡도**: O(m×n) - 최악의 경우, 큐에 모든 셀이 저장될 수 있습니다.

#### 썩은 오렌지 확산의 핵심 포인트
1. **레벨별 BFS**: 각 레벨(시간 단위)마다 모든 썩은 오렌지를 처리합니다.
2. **종료 조건**: 모든 신선한 오렌지가 썩었거나, 더 이상 썩게 만들 수 없는 경우에 종료합니다.
3. **불가능한 경우 처리**: 모든 썩은 오렌지를 처리한 후에도 신선한 오렌지가 남아있으면 -1을 반환합니다.

이 문제는 실제 생활에서의 감염 확산 모델링과 유사하며, 그래프 탐색을 통해 시간 경과에 따른 상태 변화를 시뮬레이션하는 좋은 예입니다.
