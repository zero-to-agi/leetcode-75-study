# Day 8 문제 상세 해설

## 1. Clone Graph

### 문제 설명
주어진 그래프의 복사본을 만드는 문제입니다. 그래프는 인접 리스트 형태로 표현되며, 각 노드는 값(val)과 이웃 노드 리스트(neighbors)를 가집니다.

그래프는 연결되어 있고 무방향(undirected)이며, 각 노드는 고유한 값을 갖습니다. 그래프의 한 노드가 주어졌을 때, 이 노드를 시작점으로 하는 그래프 전체의 깊은 복사본(deep copy)을 반환해야 합니다.

### 입력 예시
- `adjList = [[2,4],[1,3],[2,4],[1,3]]` (노드 1은 노드 2와 4를 이웃으로 가짐)
- `adjList = [[]]` (노드 1은 이웃이 없음)
- `adjList = []` (빈 그래프)

### 출력 예시
입력과 동일한 구조를 가진 그래프의 복사본

### 접근 방법 상세 설명
이 문제는 **그래프 탐색**과 **해시 맵**을 활용하여 해결할 수 있습니다. 그래프를 복제하기 위해서는 모든 노드를 방문하고, 각 노드와 그 이웃들 사이의 연결 관계를 유지해야 합니다. 여기서 중요한 점은 이미 복제된 노드를 다시 복제하지 않아야 한다는 것입니다.

두 가지 주요 접근 방법이 있습니다:

#### 방법 1: 깊이 우선 탐색(DFS)
1. 원본 노드에서 깊이 우선 탐색을 시작합니다.
2. 각 원본 노드에 대해 복제 노드를 생성하고, 해시 맵에 저장합니다.
3. 각 원본 노드의 이웃에 대해 재귀적으로 복제하고, 복제된 노드의 neighbors 리스트에 추가합니다.

#### 방법 2: 너비 우선 탐색(BFS)
1. 원본 노드에서 너비 우선 탐색을 시작합니다.
2. 큐를 사용하여 각 노드와 그 이웃을 순회합니다.
3. 각 원본 노드에 대해 복제 노드를 생성하고, 해시 맵에 저장합니다.
4. 각 노드의 이웃을 복제하고 연결합니다.

여기서는 DFS 방법을 사용하여 구현하겠습니다.

#### 알고리즘 단계별 설명 (DFS)
1. 빈 해시 맵 `visited`를 생성하여 각 원본 노드와 해당 복제 노드를 매핑합니다.
2. DFS 함수를 정의합니다:
   - 현재 노드가 이미 방문되었으면 복제 노드를 반환합니다.
   - 그렇지 않으면 새 노드를 생성하고 해시 맵에 저장합니다.
   - 현재 노드의 각 이웃에 대해 DFS를 재귀적으로 호출하고 결과를 복제 노드의 이웃 리스트에 추가합니다.
3. 주어진 노드로 DFS를 시작하고 결과를 반환합니다.

#### 코드 구현 (DFS)
```python
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node):
    if not node:
        return None
    
    # 원본 노드를 키로, 복제 노드를 값으로 하는 해시 맵
    visited = {}
    
    def dfs(original_node):
        # 이미 복제된 노드는 다시 복제하지 않음
        if original_node in visited:
            return visited[original_node]
        
        # 새 노드 생성
        clone_node = Node(original_node.val)
        visited[original_node] = clone_node
        
        # 이웃 노드들 복제
        for neighbor in original_node.neighbors:
            clone_node.neighbors.append(dfs(neighbor))
        
        return clone_node
    
    return dfs(node)
```

#### 단계별 예시
입력: `adjList = [[2,4],[1,3],[2,4],[1,3]]` (1번 노드는 2번과 4번을 이웃으로 가짐)

1. 1번 노드에서 DFS 시작:
   - 1번 노드를 복제하여 새 노드 생성: `clone_1`
   - `visited = {1: clone_1}`
   - 1번 노드의 이웃(2, 4)에 대해 DFS 호출

2. 2번 노드에 대한 DFS:
   - 2번 노드를 복제하여 새 노드 생성: `clone_2`
   - `visited = {1: clone_1, 2: clone_2}`
   - 2번 노드의 이웃(1, 3)에 대해 DFS 호출
   
3. 이미 방문한 1번 노드에 대한 DFS:
   - `clone_1` 반환 (재복제 방지)
   - `clone_2.neighbors = [clone_1, ...]`

4. 3번 노드에 대한 DFS:
   - 3번 노드를 복제하여 새 노드 생성: `clone_3`
   - `visited = {1: clone_1, 2: clone_2, 3: clone_3}`
   - 3번 노드의 이웃(2, 4)에 대해 DFS 호출
   
5. 이미 방문한 2번 노드에 대한 DFS:
   - `clone_2` 반환
   - `clone_3.neighbors = [clone_2, ...]`

6. 4번 노드에 대한 DFS:
   - 4번 노드를 복제하여 새 노드 생성: `clone_4`
   - `visited = {1: clone_1, 2: clone_2, 3: clone_3, 4: clone_4}`
   - 4번 노드의 이웃(1, 3)에 대해 DFS 호출

7. 이미 방문한 1번과 3번 노드에 대한 DFS:
   - `clone_1`과 `clone_3` 반환
   - `clone_4.neighbors = [clone_1, clone_3]`

8. 모든 재귀 호출이 완료되어 `clone_1`을 반환

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(N+E) - 모든 노드(N)와 간선(E)을 한 번씩 방문합니다.
- **공간 복잡도**: O(N) - 해시 맵에는 모든 노드가 저장되고, 재귀 호출 스택의 깊이도 최대 N입니다.

#### 그래프 복제의 핵심 포인트
1. **중복 방지**: 해시 맵을 사용하여 이미 방문한 노드를 추적합니다.
2. **깊은 복사**: 그래프의 모든 노드와 간선을 완전히 복제합니다.
3. **순환 처리**: 그래프에는 순환이 있을 수 있으므로 이를 올바르게 처리해야 합니다.

이 문제는 그래프 탐색과 해시 맵을 결합하여 해결하는 좋은 예입니다. DFS와 BFS 모두 사용할 수 있으며, 중요한 점은 이미 방문한 노드를 추적하는 메커니즘을 갖추는 것입니다.

## 2. Course Schedule

### 문제 설명
총 `numCourses` 개의 과목(0부터 numCourses-1까지 번호가 매겨짐)이 있고, 일부 과목에는 선수 과목이 있습니다. 선수 과목 관계는 `prerequisites` 배열로 주어지며, `prerequisites[i] = [a_i, b_i]`는 과목 `a_i`를 수강하기 위해 먼저 과목 `b_i`를 수강해야 함을 의미합니다.

모든 과목을 수강할 수 있는지 여부를 반환해야 합니다. 즉, 선수 과목 관계가 순환(cycle)을 형성하지 않아야 합니다.

### 입력 예시
- `numCourses = 2, prerequisites = [[1,0]]` (1번 과목을 수강하려면 먼저 0번 과목을 수강해야 함)
- `numCourses = 2, prerequisites = [[1,0],[0,1]]` (순환 관계: 1번 과목은 0번을 필요로 하고, 0번은 1번을 필요로 함)

### 출력 예시
- `numCourses = 2, prerequisites = [[1,0]]` → `true` (0번 과목을 먼저 수강한 후 1번 과목을 수강할 수 있음)
- `numCourses = 2, prerequisites = [[1,0],[0,1]]` → `false` (순환 관계로 인해 모든 과목을 수강할 수 없음)

### 접근 방법 상세 설명
이 문제는 **사이클 감지(Cycle Detection)** 문제로, 방향 그래프(Directed Graph)에서 사이클이 있는지 확인하는 문제입니다. 두 가지 주요 접근 방법이 있습니다:

#### 방법 1: 깊이 우선 탐색(DFS)을 이용한 사이클 감지
1. 그래프를 인접 리스트로 표현합니다.
2. 각 노드에 대해 DFS를 수행하며 사이클을 감지합니다.
3. 사이클을 감지하기 위해 각 노드의 방문 상태를 추적합니다:
   - 방문하지 않음(0): 아직 방문하지 않은 노드
   - 방문 중(1): 현재 DFS 경로에서 방문 중인 노드
   - 방문 완료(2): DFS가 완료된 노드
4. DFS 중에 "방문 중" 상태의 노드를 다시 방문하게 되면 사이클이 있는 것입니다.

#### 방법 2: 위상 정렬(Topological Sort)을 이용한 방법
1. 각 노드(과목)의 진입 차수(in-degree)를 계산합니다.
2. 진입 차수가 0인 노드부터 시작하여 큐에 넣습니다.
3. 큐에서 노드를 하나씩 꺼내서 해당 노드가 가리키는 모든 노드의 진입 차수를 1 감소시키고, 진입 차수가 0이 된 노드를 큐에 추가합니다.
4. 모든 노드를 방문할 수 있으면(총 방문 노드 수 = numCourses) 사이클이 없는 것입니다.

여기서는 DFS 방법을 사용하여 구현하겠습니다.

#### 알고리즘 단계별 설명 (DFS)
1. 그래프를 인접 리스트로 표현합니다.
2. 방문 상태를 추적하는 배열을 초기화합니다.
3. 각 노드에 대해 DFS를 수행합니다:
   - 노드가 이미 방문 완료되었으면 넘어갑니다.
   - 노드가 방문 중이면 사이클이 있으므로 False를 반환합니다.
   - 그렇지 않으면 노드를 방문 중 상태로 표시하고 모든 이웃 노드에 대해 재귀적으로 DFS를 수행합니다.
   - DFS가 완료되면 노드를 방문 완료 상태로 표시합니다.
4. 모든 노드에 대해 사이클이 감지되지 않으면 True를 반환합니다.

#### 코드 구현 (DFS)
```python
def canFinish(numCourses, prerequisites):
    # 그래프 생성 (인접 리스트)
    graph = [[] for _ in range(numCourses)]
    for dest, src in prerequisites:
        graph[src].append(dest)
    
    # 방문 상태: 0 = 방문하지 않음, 1 = 방문 중, 2 = 방문 완료
    visited = [0] * numCourses
    
    def dfs(node):
        # 이미 방문 완료된 노드
        if visited[node] == 2:
            return True
        
        # 방문 중인 노드 (사이클 발견)
        if visited[node] == 1:
            return False
        
        # 노드를 방문 중으로 표시
        visited[node] = 1
        
        # 모든 이웃 노드에 대해 DFS 수행
        for neighbor in graph[node]:
            if not dfs(neighbor):
                return False
        
        # 노드를 방문 완료로 표시
        visited[node] = 2
        return True
    
    # 모든 노드에 대해 DFS 수행
    for i in range(numCourses):
        if not dfs(i):
            return False
    
    return True
```

#### 단계별 예시
입력: `numCourses = 2, prerequisites = [[1,0]]` (1번 과목을 수강하려면 먼저 0번 과목을 수강해야 함)

1. 그래프 생성: `graph = [[], [0]]` (0번 노드는 이웃이 없고, 1번 노드는 0번을 가리킴)
2. 0번 노드에 대한 DFS:
   - `visited[0] = 1` (방문 중)
   - 이웃 노드가 없으므로 DFS 종료
   - `visited[0] = 2` (방문 완료)
   - `True` 반환
3. 1번 노드에 대한 DFS:
   - `visited[1] = 1` (방문 중)
   - 0번 노드에 대한 DFS: 이미 방문 완료되었으므로 `True` 반환
   - `visited[1] = 2` (방문 완료)
   - `True` 반환
4. 최종 결과: `True` (모든 과목을 수강할 수 있음)

입력: `numCourses = 2, prerequisites = [[1,0],[0,1]]` (순환 관계)

1. 그래프 생성: `graph = [[1], [0]]` (0번 노드는 1번을 가리키고, 1번 노드는 0번을 가리킴)
2. 0번 노드에 대한 DFS:
   - `visited[0] = 1` (방문 중)
   - 1번 노드에 대한 DFS:
     - `visited[1] = 1` (방문 중)
     - 0번 노드에 대한 DFS: 이미 방문 중이므로 사이클 발견, `False` 반환
     - `False` 반환
   - `False` 반환
3. 최종 결과: `False` (사이클로 인해 모든 과목을 수강할 수 없음)

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(V+E) - 모든 노드(V)와 간선(E)을 한 번씩 방문합니다.
- **공간 복잡도**: O(V+E) - 그래프 표현에 O(V+E), 방문 상태 배열에 O(V), 재귀 호출 스택에 O(V)의 공간이 필요합니다.

#### 과목 스케줄링의 핵심 포인트
1. **그래프 표현**: 선수 과목 관계를 방향 그래프로 표현합니다.
2. **사이클 감지**: 방향 그래프에서 사이클이 있는지 확인하는 알고리즘을 적용합니다.
3. **방문 상태 추적**: DFS를 사용할 때 노드의 방문 상태를 세 가지로 구분하여 사이클을 효과적으로 감지합니다.

이 문제는 그래프 이론에서 사이클 감지와 위상 정렬의 개념을 이해하는 데 좋은 연습이 됩니다. 실제로 대학의 과목 스케줄링, 빌드 시스템의 의존성 해결 등 다양한 실제 상황에서 유사한 문제가 발생합니다.

## 3. Pacific Atlantic Water Flow

### 문제 설명
`m × n` 크기의 2D 격자가 있으며, 각 셀의 높이를 나타내는 정수 행렬 `heights`가 주어집니다. 이 격자의 왼쪽과 위쪽 가장자리는 태평양(Pacific Ocean)과 접해 있고, 오른쪽과 아래쪽 가장자리는 대서양(Atlantic Ocean)과 접해 있습니다.

비가 내리면 물이 높은 셀에서 낮은 셀로만 흐를 수 있습니다(높이가 같으면 흐를 수 없음). 모든 셀에서 비가 내릴 때, 물이 태평양과 대서양 모두로 흘러갈 수 있는 셀의 좌표를 반환해야 합니다.

### 입력 예시
- `heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`
- `heights = [[2,1],[1,2]]`

### 출력 예시
- `heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]` → `[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]`
- `heights = [[2,1],[1,2]]` → `[[0,0],[0,1],[1,0],[1,1]]`

### 접근 방법 상세 설명
이 문제는 **다중 시작점 DFS/BFS** 문제로, 역방향 접근법을 사용하여 효율적으로 해결할 수 있습니다. 주요 아이디어는 다음과 같습니다:

1. 태평양과 접하는 모든 셀에서 시작하여 물이 흘러올 수 있는 셀들을 찾습니다(높은 곳에서 낮은 곳으로 흐르므로, 역으로 낮은 곳에서 높거나 같은 곳으로 탐색).
2. 마찬가지로 대서양과 접하는 모든 셀에서 시작하여 물이 흘러올 수 있는 셀들을 찾습니다.
3. 두 집합의 교집합이 태평양과 대서양 모두로 물이 흘러갈 수 있는 셀들입니다.

#### 알고리즘 단계별 설명
1. 두 개의 방문 배열을 생성합니다: 태평양으로 흘러갈 수 있는 셀을 추적하는 `pacific`과 대서양으로 흘러갈 수 있는 셀을 추적하는 `atlantic`.
2. 태평양 경계(첫 번째 행과 첫 번째 열)에서 DFS/BFS를 시작하여 `pacific` 배열을 채웁니다.
3. 대서양 경계(마지막 행과 마지막 열)에서 DFS/BFS를 시작하여 `atlantic` 배열을 채웁니다.
4. 두 배열 모두에서 방문으로 표시된 셀의 좌표를 결과 리스트에 추가합니다.

여기서는 DFS를 사용하여 구현하겠습니다.

#### 코드 구현 (DFS)
```python
def pacificAtlantic(heights):
    if not heights or not heights[0]:
        return []
    
    m, n = len(heights), len(heights[0])
    pacific = set()
    atlantic = set()
    
    def dfs(row, col, visited):
        visited.add((row, col))
        # 4방향: 상, 하, 좌, 우
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        for dr, dc in directions:
            r, c = row + dr, col + dc
            # 격자 내부에 있고, 아직 방문하지 않았으며, 현재 위치보다 높거나 같은 경우
            if (0 <= r < m and 0 <= c < n and 
                (r, c) not in visited and 
                heights[r][c] >= heights[row][col]):
                dfs(r, c, visited)
    
    # 태평양 경계(첫 번째 행과 첫 번째 열)에서 DFS 시작
    for i in range(m):
        dfs(i, 0, pacific)
    for j in range(n):
        dfs(0, j, pacific)
    
    # 대서양 경계(마지막 행과 마지막 열)에서 DFS 시작
    for i in range(m):
        dfs(i, n-1, atlantic)
    for j in range(n):
        dfs(m-1, j, atlantic)
    
    # 두 집합의 교집합 찾기
    return list(pacific.intersection(atlantic))
```

#### 단계별 예시
입력: `heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`

1. 태평양 경계에서 DFS 수행:
   - 첫 번째 열의 각 셀 (0,0), (1,0), (2,0), (3,0), (4,0)에서 시작
   - 첫 번째 행의 각 셀 (0,0), (0,1), (0,2), (0,3), (0,4)에서 시작
   - 결과: `pacific = {(0,0), (0,1), (0,2), (0,3), (0,4), (1,0), (1,1), (1,2), (1,3), (1,4), (2,0), (2,1), (2,2), (3,0), (3,1), (4,0)}`

2. 대서양 경계에서 DFS 수행:
   - 마지막 열의 각 셀 (0,4), (1,4), (2,4), (3,4), (4,4)에서 시작
   - 마지막 행의 각 셀 (4,0), (4,1), (4,2), (4,3), (4,4)에서 시작
   - 결과: `atlantic = {(0,4), (1,3), (1,4), (2,2), (2,3), (2,4), (3,0), (3,1), (3,2), (3,3), (3,4), (4,0), (4,1), (4,2), (4,3), (4,4)}`

3. 두 집합의 교집합: `pacific ∩ atlantic = {(0,4), (1,3), (1,4), (2,2), (3,0), (3,1), (4,0)}`

4. 결과 정렬: `[[0,4], [1,3], [1,4], [2,2], [3,0], [3,1], [4,0]]`

#### 시간 및 공간 복잡도
- **시간 복잡도**: O(m*n) - 각 셀을 최대 2번 방문합니다(태평양 DFS와 대서양 DFS).
- **공간 복잡도**: O(m*n) - 방문 집합에 최악의 경우 모든 셀이 저장될 수 있고, 재귀 호출 스택의 깊이도 최대 m*n입니다.

#### 태평양 대서양 물 흐름의 핵심 포인트
1. **역방향 접근법**: 물이 높은 곳에서 낮은 곳으로 흐르므로, 역으로 낮은 곳에서 높거나 같은 곳으로 탐색합니다.
2. **다중 시작점**: 태평양과 대서양 경계에서 시작하여 도달 가능한 모든 셀을 찾습니다.
3. **집합 연산**: 두 집합의 교집합을 찾아 결과를 구합니다.

이 문제는 그래프 탐색의 응용과 역방향 사고를 요구하는 좋은 예입니다. DFS나 BFS 모두 사용할 수 있으며, 중요한 점은 문제의 조건을 역으로 적용하여 효율적인 해결책을 찾는 것입니다.

